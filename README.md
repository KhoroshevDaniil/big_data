# Лабораторные работы "Big Data" 2023

## ЛР 1
Jupyter блакнот с кодом доступен [здесь](/6132_Khoroshev_Lab1.ipynb)

Примечания к лабораторной:<br/>
1. Для вычисления геодезического расстояния во втором задании ЛР использовалась написанная вручную функция ```computeDistance(lat1, lon1, lat2, lon2)```, использующая геодезические точки Latitude и Longitude. Затем вычислялось расстояние между каждой парой станций (для этого делал ```crossJoin```) и выбиралось максимальное значение.
2. Не доконца понял смысл третьего задания ЛР, поэтому посчитал наибольшее расстояние, которое преодолел велосипедист между двумя станциями. Расчёт был, так же как описано выше, по всем парам станций.

## ЛР 2
Jupyter блакнот с кодом доступен [здесь](/6132_Khoroshev_Lab2.ipynb)

Ход выполнения ЛР:<br/>
1. Сначала я отбросил все записи, где поле ```_Tags is null```
2. От поля ```_CreationDate``` оставил только год
3. Отформатировал поле ```_Tags``` (убрал стрелочки '<' и '>')
4. Затем я отбросил все записи, где год не попадает в диапазон, описанный в задании к ЛР (2010 - 2020)
5. После махинаций, описанных выше, получился датафрейм со столбцами ```year```, ```views``` и ```languages```
6. С помощью функции ```pyspark.sql.functions.explode``` разбил строчки, где много языков, на множество других строк, чтобы поле ```year``` и ```views``` было одинаковым, но в поле ```languages``` был только 1 язык (переименовал ```languages``` в ```language```)
7. Далее я убрал все строки, где значение поля ```languages``` не является по сути ЯП (то есть, "языка" нет в списке ЯП из ```programming-languages.csv```)
8. Далее подсчитал суммы поля ```views```, сгруппировав таблицу по ```year``` и ```language```
9. С помощью класса ```pyspark.sql.window.Window``` и функции ```pyspark.sql.functions.row_number``` посчитал номер популярности каждого языка в каждом году (появилось поле ```rank```)
10. Убрал все строчки, где ```rank``` меньше 10 (по сути оставил топ 10 языков) и отсортировал по годам в порядке убывания